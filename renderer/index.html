<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<title>imgs2gif</title>
		<link rel="stylesheet" href="../styles/element.css" />
		<style>
			* {
				padding: 0;
				margin: 0;
				box-sizing: border-box;
			}
			.el-dialog__body {
				padding: 20px !important;
			}

			.el-dialog__header {
				padding-bottom: 0px !important;
			}
			#app {
				padding: 10px;
			}
			#uploadPage {
				width: 100%;
				height: 100%;
				position: relative;
			}
			#imgsShow {
				width: 100%;
				height: 415px;
				overflow-y: scroll;
				/* padding-bottom: 20px; */
			}
			#imgsShow::-webkit-scrollbar {
				width: 0 !important;
			}
			.submitBtn {
				width: 100%;
				/* position: fixed; */
				/* bottom: 10px; */
				/* width: calc(100% - 20px); */
				/* left: 10px; */
			}
		</style>
	</head>

	<body>
		<div id="app" v-loading="loading">
			<div id="uploadPage" v-show="uploadPageVisible">
				<div id="imgsShow">
					<el-upload
						action="https://jsonplaceholder.typicode.com/posts/"
						list-type="picture-card"
						:on-preview="handlePictureCardPreview"
						:on-remove="handleRemove"
						:on-success="handleSuccess"
						:on-change="handleChange"
						:auto-upload="true"
						:multiple="true"
						ref="upload"
						:http-request="httpRequest"
					>
						<i class="el-icon-plus"></i>
					</el-upload>
				</div>

				<el-button type="primary" @click="submitList" class="submitBtn">
					submit
				</el-button>
			</div>
			<div id="setPage" v-show="setPageVisible">
				<ul class="setForm">
					<li>
						<span>设置宽度:</span>
						<input type="number" v-model="setOptions.gifWidth" @blur="createGif"/>
					</li>
					<li>
						<span>设置高度:</span>
						<input type="number" v-model="setOptions.gifHeight" @blur="createGif"/>
					</li>
					<li>
						<span>设置切换间隔:</span>
						<input type="number" v-model="setOptions.interval" @blur="createGif"/>
					</li>
					<li>
						<el-button @click="createGif">生成gif</el-button>
						<el-button @click="goto('uploadPage')">重新选图</el-button>
						<el-button @click="savePicture">保存到本地</el-button>
					</li>
				</ul>
				<img :src="imgUrl" alt="gif" />
			</div>
			<el-dialog :visible.sync="dialogVisible" :title="dialogTitle">
				<img width="100%" :src="dialogImageUrl" alt="" />
			</el-dialog>
		</div>
		<script
			src="../scripts/vue.min.js"
			type="application/javascript"
		></script>
		<script
			src="../scripts/element.js"
			type="application/javascript"
		></script>
		<script src="../scripts/gifshot.min.js"></script>
		<script>
			const { ipcRenderer } = require('electron')
			new Vue({
				el: '#app',
				data() {
					return {
						dialogImageUrl: '',
						dialogVisible: false,
						filelist: [],
						imgUrl: '',
						dialogTitle: '',
						loading: false,
						setPageVisible: false,
						uploadPageVisible: true,
						form: {
							name: '',
							region: '',
							date1: '',
							date2: '',
							delivery: false,
							type: [],
							resource: '',
							desc: '',
						},
						setOptions: {
							gifWidth: 200,
							gifHeight: 200,
							interval: 0.1,
						},
					}
				},
				methods: {
					handleRemove(file, fileList) {
						console.log(file, fileList)
					},
					handleSuccess(file, fileList) {
						console.log(file, fileList)
					},
					handleChange(file, fileList) {
						console.log(file, fileList)
					},
					handlePictureCardPreview(file) {
						this.dialogTitle = file.name
						this.dialogImageUrl = file.url
						this.dialogVisible = true
					},
					httpRequest(demo1, demo2) {
						console.log(demo1, demo2)
					},
					submitList() {
						this.loading = true
						const array = this.$refs.upload.uploadFiles
						const arr = []
						array.forEach((file, index) => {
							var reader = new FileReader()
							reader.onload = e => {
								arr.push(e.target.result)
								if (index == array.length - 1) {
									// console.log(arr);

									this.fileList = arr
									this.createGif(arr)
									this.goto('setPage')
								}
							}
							reader.readAsDataURL(file.raw)
						})
						// reader.readAsDataURL(files[key])
						// console.log()
					},
					goto(target) {
						if (target === 'uploadPage') {
							this.uploadPageVisible = true
							this.setPageVisible = false
						} else if (target === 'setPage') {
							this.uploadPageVisible = false
							this.setPageVisible = true
						}
					},
					onSubmit() {
						console.log('submit!')
					},
					createGif() {
						this.loading = true
						const params = this.fileList
						const { gifWidth, gifHeight, interval } = this.setOptions
						const that = this
						gifshot.createGIF(
							{
								images: params,
								gifWidth,
								gifHeight,
								interval, // seconds
								progressCallback: function (captureProgress) {
									if (captureProgress == 1) {
										that.loading = false
										// that.setPageVisible = true
										// that.uploadPageVisible = false
									}
								},
								completeCallback: () => {
									console.log(this)
								},
								numWorkers: 2,
							},
							obj => {
								// console.log(obj);
								that.loading = false
								this.imgUrl = obj.image
								// ipcRenderer.send('download', obj.image)
								// this.savePicture(obj)
								// console.log(obj)
							}
						)
					},
					savePicture() {
						const Url = this.imgUrl
						var blob = new Blob([''], {
							type: 'application/octet-stream',
						})
						var url = URL.createObjectURL(blob)
						var a = document.createElement('a')
						a.href = Url
						a.download = Url.replace(
							/(.*\/)*([^.]+.*)/gi,
							'$2'
						).split('?')[0]
						var e = document.createEvent('MouseEvents')
						e.initMouseEvent(
							'click',
							true,
							false,
							window,
							0,
							0,
							0,
							0,
							0,
							false,
							false,
							false,
							false,
							0,
							null
						)
						a.dispatchEvent(e)
						URL.revokeObjectURL(url)
					},
				},
				// watch: {
				// 	setOptions: {
				// 		deep: true,
				// 		handler(){
				// 			this.createGif()
				// 		}
				// 	}
				// }
			})
		</script>
	</body>
</html>
